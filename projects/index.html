<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Projects — Stay Real</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;800;900&family=Orbitron:wght@500;700;900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/css/styles.css">
  <style>
    body{
      margin:0;
      color:#111;
      font-family: 'Outfit', system-ui, -apple-system, sans-serif;
      -webkit-font-smoothing:antialiased; 
      text-rendering:optimizeLegibility;
      overflow: hidden; /* Keep overflow hidden for this specific page's animation */
    }
    canvas#stage{
      position:fixed; 
      inset:0; 
      width:100vw; 
      height:100vh; 
      display:block; 
      z-index: 1; /* Behind other content */
      background: transparent;
    }
    .hint{position:fixed; left:50%; bottom:26px; transform:translateX(-50%);
      background:rgba(0,0,0,.04); border:1px solid rgba(0,0,0,.07); color:#333;
      padding:8px 12px; border-radius:12px; font-size:12px; letter-spacing:.2px; z-index:100;
      transition: opacity 0.3s ease;}

    .skill-button {
      position: fixed;
      transform: translate(-50%, -50%);
      background: #111; color: white; border: none;
      padding: 18px 36px; border-radius: 36px; /* bigger */
      font-family: 'Outfit', sans-serif; font-weight: 600; font-size: 18px; /* bigger */
      cursor: pointer; opacity: 0; pointer-events: none; z-index: 2;
      transition: all 0.6s cubic-bezier(0.2, 0.8, 0.3, 1.1);
      box-shadow: 0 8px 20px rgba(0,0,0,0.12); scale: 0.5;
      overflow: hidden; /* for light effect mask */
      --x: 50%; --y: 50%;
    }
    .skill-button.visible { opacity: 1; pointer-events: auto; scale: 1; }

    /* natural light effect on click */
    .skill-button::after{
      content: '';
      position: absolute;
      left: calc(var(--x) - 60px);
      top: calc(var(--y) - 60px);
      width: 120px; height: 120px;
      border-radius: 50%;
      pointer-events: none;
      background: radial-gradient(circle at center,
        rgba(255,255,255,0.85) 0%,
        rgba(255,255,255,0.55) 30%,
        rgba(255,255,255,0.12) 60%,
        rgba(255,255,255,0) 75%);
      mix-blend-mode: screen;
      opacity: 0; transform: scale(0.6);
      transition: opacity .6s ease, transform .6s ease;
      filter: blur(0.5px);
    }
    .skill-button.lit::after{
      opacity: 1; transform: scale(1.25);
    }

    .nav { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 100; }
    .links { display: flex; gap: 12px; }
    .pill { padding: 8px 16px; background: rgba(255,255,255,0.9);
      border:1px solid rgba(0,0,0,0.1); border-radius:20px; text-decoration:none;
      color:#333; font-size:14px; transition: all 0.2s ease; }
    .pill:hover { background: rgba(0,0,0,0.05); }
    .pill.active { background: #111; color: white; }

    footer { position: fixed; bottom: 20px; right: 20px; font-size: 12px; color: rgba(0,0,0,0.6); z-index: 100; }

    /* Phrase lines (bigger + farther) */
    .phrase-line{
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      font-weight: 900;
      font-size: clamp(36px, 5vw, 84px); /* bigger */
      letter-spacing: .4px; color: #111;
      z-index: 5; opacity: 0; transition: opacity .35s ease;
      pointer-events: none; white-space: nowrap; mix-blend-mode: normal;
    }
    .phrase-line.visible{ opacity: 1; }
    .phrase-line .segment{
      display: inline-block; opacity: 0; transform: translateY(10px);
      transition: opacity .5s ease, transform .5s cubic-bezier(.2,.8,.2,1);
      margin: 0 .32em;
    }
    .phrase-line .segment.revealed{ opacity: 1; transform: translateY(0); }

    /* Modal (black popup) */
    .modal-backdrop{
      position: fixed; inset: 0; z-index: 9999;
      background: rgba(0,0,0,0.8);
      opacity: 0; pointer-events: none;
      transition: opacity .28s ease;
    }
    .modal-backdrop.visible{ opacity:1; pointer-events:auto; }
    .modal-content{
      position: absolute; left:50%; top:50%; transform: translate(-50%,-50%);
      width: min(90vw, 860px); min-height: 60vh;
      background: #000; color: #fff;
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px; box-shadow: 0 24px 72px rgba(0,0,0,0.5);
      padding: 24px 24px 32px;
      max-height: 90vh;
      overflow-y: auto;
    }
    .modal-close{
      position:absolute; right:12px; top:10px;
      width:36px; height:36px; border-radius:10px;
      background: rgba(255,255,255,0.06); color:#fff;
      border: 1px solid rgba(255,255,255,0.12);
      cursor: pointer; font-size:20px; line-height: 1;
      display:flex; align-items:center; justify-content:center;
      transition: background .2s ease, transform .2s ease;
    }
    .modal-close:hover{ background: rgba(255,255,255,0.12); transform: translateY(-1px); }
    .modal-body{ margin-top: 28px; color:#ddd; font-size: 15px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
  <script defer src="../assets/js/particles-config.js"></script>
</head>
<body>
  <div id="particles-js"></div>
  <canvas id="stage" aria-label="Interactive cube particle field"></canvas>
  <div class="hint" id="hint">Move your cursor to the center to transform the cube • Tap center on mobile</div>

  <!-- phrase containers (filled by JS) -->
  <div id="phraseTop" class="phrase-line" aria-hidden="true"></div>
  <div id="phraseBottom" class="phrase-line" aria-hidden="true"></div>

  <!-- reusable black modal popup -->
  <div id="modal" class="modal-backdrop" aria-hidden="true">
    <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <button class="modal-close" aria-label="Close">×</button>
      <div class="modal-body">
        <h2 id="modalTitle" style="margin:0;font-size:20px;font-weight:800;letter-spacing:.2px;">Coming soon</h2>
        <p style="opacity:.8;margin-top:8px;">This section will be filled with project details.</p>
      </div>
    </div>
  </div>

  <header>
    <nav class="nav">
      <div class="links">
        <a class="pill" href="../">Home</a>
        <a class="pill active" href="../projects/">Projects</a>
        <a class="pill" href="../services/">Services</a>
        <a class="pill" href="../contact/">Contact Info</a>
      </div>
    </nav>
  </header>
  <footer>
    &copy; <span id="year">2025</span> Alex Shvachko — Stay Real.
  </footer>

  <script>
  (function(){
    const cvs = document.getElementById('stage');
    const ctx = cvs.getContext('2d');
    const hint = document.getElementById('hint');
    const phraseTop = document.getElementById('phraseTop');
    const phraseBottom = document.getElementById('phraseBottom');
    const modalEl = document.getElementById('modal');
    const modalClose = modalEl.querySelector('.modal-close');
    const DPR = Math.min(devicePixelRatio || 1, 2);

    let W=0, H=0, last=performance.now();
    let GRID = 105, SIZE = 0, CX=0, CY=0, CELL=0;

    // State machine: 'idle' -> 'phrase' -> 'dismember' -> 'done'
    let phase = 'idle';
    let transformTriggered = false;
    let transformProgress = 0;
    let transformComplete = false;
    let distortionAmount = 0;

  const projects = {
    'Data Science': {
      title: 'Ambulances at the Door: Predicting ER Off-Load Delays (Israel, 2022)',
      content: `
        <h2>Backstory</h2>
        <p>Ambulances were arriving to ERs and waiting on stretchers because no bed was immediately available. That delay cascades: worse patient experience, staff overload, and lower system throughput. I set out to measure the problem end-to-end and predict delays so dispatchers and ERs can act before bottlenecks form.</p>
        
        <h2>Data & Label</h2>
        <p>436,7k+ ambulance→ER entries (2022, nationwide) with timestamps, location, patient age, clinical code, arrival hour, ER load proxies, and more.</p>
        <p>Engineered features: hospital size & region, shift (day/evening/night), simultaneous ambulance arrivals, and current ER occupancy proxy.</p>
        <p>Delay definition ("bottleneck") followed operational rules: ≥20 min for BLS, ≥30 min for ALS/paramedic off-load.</p>
        <p><strong>Fun (scary) fact:</strong> mean wait ≈ 36.2 min, and ~79.5% of arrivals met the "delayed" threshold—so this is systemic, not anecdotal.</p>
        
        <h2>Approach</h2>
        <p>Cleaning + feature engineering; categorical encoding & normalization; train/valid splits with cross-validation.</p>
        <p>Tried logistic regression; moved to Random Forest to capture non-linear interactions and mixed feature types.</p>
        <p>Imputation and sanity checks for extreme ages/outliers; visual analysis of seasonality & hourly patterns.</p>
        
        <h2>Results (Classifier)</h2>
        <p>Optimized for high recall (better to flag potential delays than miss them):</p>
        <p>Test F1: 0.885 Precision: 0.801 Recall: 0.989<br>
        Accuracy: 0.797 Specificity: 0.055 (expected tradeoff)<br>
        ROC-AUC: 0.692 (room to lift with richer real-time features)</p>
        <p><em>Translation:</em> the model catches almost all delay cases; it intentionally over-alerts when capacity is tight. (Threshold can be tuned per hospital.)</p>
        
        <h2>What drives delay (feature importance)</h2>
        <ul>
          <li>Patient age—older patients increase off-load time (bed type/triage complexity).</li>
          <li>ER occupancy % at arrival—the denser the unit, the slower the handoff.</li>
          <li>Arrival hour/shift and simultaneous ambulance load—crowding effects.</li>
          <li>Clinical code (chief complaint)—certain cases require more prep.</li>
          <li>Geography/facility size and crew/base metadata—local operating patterns.</li>
        </ul>
        
        <h2>Key Insights (operational)</h2>
        <ul>
          <li>Capacity, not paperwork, is the bottleneck. Delay tracks ER occupancy and batch arrivals.</li>
          <li>Routing beats waiting. Steering borderline cases to nearby, less-crowded ERs should reduce queueing.</li>
          <li>Age-aware triage prep (bed readiness before wheels-stop) can cut minutes where it matters most.</li>
          <li>Seasonality & time-of-day patterns are real; staff scheduling can be aligned to predicted peaks.</li>
        </ul>
        
        <h2>Challenges</h2>
        <ul>
          <li>Single-year view (2022)—good for a first pass, but more years would solidify seasonality trends.</li>
          <li>Timing discrepancies between EMS and hospital clocks; imperfect visibility into exact "bed ready" state.</li>
          <li>Label imbalance (many "delays") pushes the model toward recall; specificity is low by design and needs per-site thresholding.</li>
          <li>Limited direct signals about real-time bed availability and triage severity at minute-resolution.</li>
        </ul>
        
        <h2>What I'd Build Next (practical roadmap)</h2>
        <ul>
          <li>Per-hospital threshold calibration (precision–recall tradeoff by ops goals).</li>
          <li>Live occupancy feed + streaming features → upgrade to online inference and ETA-aware dispatch.</li>
          <li>Cost-sensitive learning (missed-delay > false-alarm) and XGBoost/GBTs with calibrated probabilities.</li>
          <li>Tactical dashboard for dispatchers: recommended destination + predicted off-load time + confidence band.</li>
          <li>A/B test: dynamic routing versus status-quo during peak windows.</li>
        </ul>
        
        <div style="text-align: center; margin-top: 2rem;">
          <img src="../assets/img/er.png" alt="ER Off-Load Delay Analysis" style="max-width: 100%; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
        </div>
      `
    },
    'Machine Learning': { title: 'Machine Learning Project', content: 'Coming soon...' },
    'Data Engineering': { title: 'Data Engineering Project', content: 'Coming soon...' },
    'Automations': { title: 'Automations Project', content: 'Coming soon...' },
    'AI Engineering': { title: 'AI Engineering Project', content: 'Coming soon...' },
    'AI Art': { title: 'AI Art Project', content: 'Coming soon...' }
  };
  
  const buttonLabels = Object.keys(projects);
  let buttons = [];
  const particles = [];

  const mouse = {x:0, y:0, active:false, vx:0, vy:0, px:0, py:0};

  // ----- Modal helpers -----
  function openModal(projectTitle) {
    const project = projects[projectTitle];
    if (project) {
      document.getElementById('modalTitle').textContent = project.title;
      document.querySelector('.modal-body').innerHTML = project.content;
      modalEl.classList.add('visible');
      modalEl.setAttribute('aria-hidden', 'false');
    }
  }
  function closeModal(){ modalEl.classList.remove('visible'); modalEl.setAttribute('aria-hidden','true'); }
  modalClose.addEventListener('click', closeModal);
  modalEl.addEventListener('click', (e)=>{ if (e.target === modalEl) closeModal(); });
  addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeModal(); });

  // ----- Phrase helpers -----
  const phraseTimeouts = [];
  const topSegments = ['What can a','data engineer'];
  const bottomSegments = ['build','in 2025?'];

  function clearPhraseTimers(){ while (phraseTimeouts.length) clearTimeout(phraseTimeouts.pop()); }
  function buildPhrase(){
    phraseTop.innerHTML = topSegments.map(t => `<span class="segment">${t}</span>`).join(' ');
    phraseBottom.innerHTML = bottomSegments.map(t => `<span class="segment">${t}</span>`).join(' ');
  }
  function positionPhrase(){
    const cxCSS = CX / DPR;

    // Farther from cube edges (scaled + mins)
    const offsetTop    = Math.max(140, SIZE * 0.32) / DPR;
    const offsetBottom = Math.max(160, SIZE * 0.36) / DPR;

    let topY = (CY - SIZE/2) / DPR - offsetTop;
    let bottomY = (CY + SIZE/2) / DPR + offsetBottom;

    // Safety to keep on screen
    topY = Math.max(12, topY);
    bottomY = Math.min((H / DPR) - 24, bottomY);

    phraseTop.style.top = `${topY}px`;
    phraseBottom.style.top = `${bottomY}px`;
    phraseTop.style.left = phraseBottom.style.left = `${cxCSS}px`;
  }
  function showPhrase(){
    phraseTop.classList.add('visible');
    phraseBottom.classList.add('visible');
  }
  function hidePhrase(){
    phraseTop.classList.remove('visible');
    phraseBottom.classList.remove('visible');
    phraseTop.querySelectorAll('.segment').forEach(s => s.classList.remove('revealed'));
    phraseBottom.querySelectorAll('.segment').forEach(s => s.classList.remove('revealed'));
  }
  function startPhraseSequence(){
    if (phase !== 'idle') return;
    phase = 'phrase';
    hint.style.opacity = '0';
    buildPhrase();
    positionPhrase();
    showPhrase();

    // Reveal 1/4 every 1.0s (slower cadence)
    const schedule = [
      { t: 0,     line: 'top',    idx: 0 },
      { t: 1000,  line: 'top',    idx: 1 },
      { t: 2000,  line: 'bottom', idx: 0 },
      { t: 3000,  line: 'bottom', idx: 1 },
    ];
    schedule.forEach(item => {
      phraseTimeouts.push(setTimeout(() => {
        const lineEl = item.line === 'top' ? phraseTop : phraseBottom;
        const seg = lineEl.querySelectorAll('.segment')[item.idx];
        if (seg) seg.classList.add('revealed');
      }, item.t));
    });

    // After last reveal at 3000ms, wait +2000ms => 5000ms total, then dismember (extra time to read)
    phraseTimeouts.push(setTimeout(() => {
      hidePhrase();         // fade out text
      triggerTransform();   // start particle → buttons
      phase = 'dismember';
    }, 5000));
  }

  // ----- Buttons -----
  function createButtons(){
    buttons.forEach(btn => btn.element && btn.element.remove());
    buttons = [];
    const angleStep = (Math.PI * 2) / buttonLabels.length;
    const radius = Math.min(W, H) * 0.25;
    buttonLabels.forEach((label, i) => {
      const btn = document.createElement('button');
      btn.className = 'skill-button'; btn.textContent = label;
      document.body.appendChild(btn);
      const angle = i * angleStep - Math.PI/2;
      const x = CX + Math.cos(angle) * radius;
      const y = CY + Math.sin(angle) * radius;
      btn.style.left = (x/DPR) + 'px';
      btn.style.top  = (y/DPR) + 'px';
      // light effect listeners
      const updateXY = (e) => {
        const r = btn.getBoundingClientRect();
        const cx = (e.clientX - r.left);
        const cy = (e.clientY - r.top);
        btn.style.setProperty('--x', cx + 'px');
        btn.style.setProperty('--y', cy + 'px');
      };
      btn.addEventListener('pointermove', updateXY);
      btn.addEventListener('pointerdown', (e) => {
        updateXY(e);
        btn.classList.add('lit');
        setTimeout(() => btn.classList.remove('lit'), 450);
      });
      btn.addEventListener('click', () => openModal(label));
      buttons.push({ element: btn, x, y, angle, radius });
    });
  }

  function fit(){
    W = cvs.width  = Math.floor(innerWidth * DPR);
    H = cvs.height = Math.floor(innerHeight * DPR);
    cvs.style.width = innerWidth+'px'; cvs.style.height = innerHeight+'px';

    SIZE = Math.floor(Math.min(W,H) * 0.34);
    CX = Math.floor(W*0.5); CY = Math.floor(H*0.5);

    GRID = Math.max(60, Math.min(150, Math.round(SIZE/6)));
    CELL = SIZE / GRID;

    createButtons();
    positionPhrase();

    if (phase === 'idle') {
      particles.length = 0;
      const startX = CX - SIZE/2 + CELL/2;
      const startY = CY - SIZE/2 + CELL/2;
      for(let gy=0; gy<GRID; gy++){
        for(let gx=0; gx<GRID; gx++){
          const hx = startX + gx*CELL, hy = startY + gy*CELL;
          particles.push({ x:hx, y:hy, vx:0, vy:0, homeX:hx, homeY:hy,
            mass:0.8+Math.random()*0.6, targetButton:null, flying:false, disappeared:false });
        }
      }
    }
  }

  function onMove(e){
    if (transformComplete) return;
    const cx = (e.touches? e.touches[0].clientX : e.clientX) * DPR;
    const cy = (e.touches? e.touches[0].clientY : e.clientY) * DPR;
    mouse.vx = (cx - mouse.px) * 0.6 + mouse.vx * 0.4;
    mouse.vy = (cy - mouse.py) * 0.6 + mouse.vy * 0.4;
    mouse.px = cx; mouse.py = cy; mouse.x = cx; mouse.y = cy; mouse.active = true;
  }

  function triggerTransform(){
    if (transformTriggered) return;
    transformTriggered = true;

    // show buttons
    buttons.forEach((btn, i) => {
      setTimeout(() => btn.element.classList.add('visible'), i * 100);
    });

    // particles fly to buttons (slightly slower launch)
    particles.forEach(p => {
      const buttonIndex = Math.floor(Math.random() * buttons.length);
      p.targetButton = buttons[buttonIndex];
      p.flying = true;
      const dx = p.targetButton.x - p.x, dy = p.targetButton.y - p.y;
      const dist = Math.hypot(dx, dy) || 1;
      const speed = 1.6 + Math.random() * 2.2; // slower initial speed
      p.vx = (dx / dist) * speed; p.vy = (dy / dist) * speed;
    });
  }

  addEventListener('mousemove', onMove, {passive:true});
  addEventListener('touchstart', onMove, {passive:true});
  addEventListener('resize', fit);

  // Distance from point to cube rect (0 if inside)
  function distToCube(px, py){
    const dx = Math.max(Math.abs(px - CX) - SIZE/2, 0);
    const dy = Math.max(Math.abs(py - CY) - SIZE/2, 0);
    return Math.hypot(dx, dy);
  }

  function step(dt){
    if (!transformTriggered && phase === 'idle') {
      if (mouse.active) {
        const d = distToCube(mouse.x, mouse.y);
        const limit = SIZE * 0.50;
        const prox = Math.max(0, 1 - d / limit);
        const speed = Math.hypot(mouse.vx, mouse.vy);
        const speedBoost = Math.min(1, speed / (28 * DPR));
        const target = Math.max(0, Math.min(1, (prox * 0.9 + speedBoost * 0.3) * 0.25));
        // Faster easing towards target (reduce perceived delay to ~0.8x)
        distortionAmount += (target - distortionAmount) * 0.00625;
      } else {
        distortionAmount *= 0.92;
      }
    }

    if (!transformTriggered) {
      if (mouse.active && phase === 'idle') {
        const dToCenter = Math.hypot(mouse.x - CX, mouse.y - CY);
        if (dToCenter <= 40 * DPR) startPhraseSequence();
      }
      return;
    }

    transformProgress = Math.min(1, transformProgress + dt * 0.008);

    for (let i=particles.length-1; i>=0; i--){
      const p = particles[i];
      if (p.disappeared) continue;

      if (p.flying && p.targetButton){
        const dx = p.targetButton.x - p.x, dy = p.targetButton.y - p.y;
        const dist = Math.hypot(dx, dy) || 1;
        if (dist < 12 * DPR){ p.disappeared = true; continue; } // must get closer → slightly longer flight

        const force = 0.06; // gentler attraction → slower break
        p.vx += (dx / dist) * force; p.vy += (dy / dist) * force;
        p.vx += (Math.random()-0.5)*0.5; p.vy += (Math.random()-0.5)*0.5;
        p.vx *= 0.98; p.vy *= 0.98;
        p.x += p.vx * (dt * 0.1); p.y += p.vy * (dt * 0.1);
      }
    }

    const remaining = particles.filter(p => !p.disappeared);
    if (remaining.length === 0 && !transformComplete){
      transformComplete = true; phase = 'done'; clearPhraseTimers();
    }
  }
  function drawCellSnapped(cx, cy, w, h, opacity = 1) {
  // final pixel-aligned rectangle with +1 px overdraw to kill seams
  const ix = Math.round(cx - w / 2);
  const iy = Math.round(cy - h / 2);
  const iw = Math.ceil(w) + 1;
  const ih = Math.ceil(h) + 1;
  if (opacity !== 1) ctx.globalAlpha = opacity;
  ctx.fillRect(ix, iy, iw, ih);
  if (opacity !== 1) ctx.globalAlpha = 1;
}

function draw(){
  // Clear/fade
  if (!transformTriggered) {
    ctx.clearRect(0,0,W,H);
  } else {
    // Fade previous frame for a trailing effect during particle phase
    ctx.save();
    ctx.globalCompositeOperation = 'destination-out';
    ctx.fillStyle = 'rgba(0,0,0,0.06)'; // adjust alpha to control trail length
    ctx.fillRect(0,0,W,H);
    ctx.restore();
  }
  if (transformComplete) return;

  if (!transformTriggered) {
    ctx.save();
    ctx.fillStyle = '#111111';

    if (distortionAmount > 0 && mouse.active) {
      const gridRes = 32;
      const cellW = SIZE / gridRes;
      const cellH = SIZE / gridRes;
      const startX = CX - SIZE/2 + cellW/2;
      const startY = CY - SIZE/2 + cellH/2;

      const maxEffect = SIZE * 0.80;
      const baseHole  = Math.max(12 * DPR, SIZE * 0.12);
      const hole      = baseHole + distortionAmount * SIZE * 0.10;

      for (let gy = 0; gy < gridRes; gy++) {
        for (let gx = 0; gx < gridRes; gx++) {
          const ox = startX + gx * cellW;
          const oy = startY + gy * cellH;

          const dx = ox - mouse.x;
          const dy = oy - mouse.y;
          const dist = Math.hypot(dx, dy) + 1e-4;

          if (dist > maxEffect) {
            // snap normal cells too
            drawCellSnapped(ox, oy, cellW, cellH);
            continue;
          }

          const t = dist / maxEffect;
          const focus = 1 - t;

          const baseTheta = focus * focus * (0.95 * Math.max(0.35, distortionAmount));
          const cross = mouse.vx * dy - mouse.vy * dx;
          const theta = baseTheta * (cross >= 0 ? 1 : -1);

          const cos = Math.cos(theta), sin = Math.sin(theta);
          let rx = cos * dx - sin * dy;
          let ry = sin * dx + cos * dy;

          const radialGain = 1 + focus * focus * (1.05 + 1.25 * distortionAmount);
          rx *= radialGain; ry *= radialGain;

          const nx = mouse.x + rx;
          const ny = mouse.y + ry;

          if (Math.hypot(nx - mouse.x, ny - mouse.y) < hole) continue;

          const scale = Math.max(0.25, Math.min(1, 1 - focus * (0.75 + 0.5 * distortionAmount)));
          const w = cellW * scale;
          const h = cellH * scale;

          // draw cell at its FINAL pixel rect (no transforms) with a 1px overdraw inside helper
          drawCellSnapped(nx, ny, w, h);
        }
      }
    } else {
      // normal solid cube — snapped to pixels for crisp edges
      const x = Math.round(CX - SIZE/2);
      const y = Math.round(CY - SIZE/2);
      const s = Math.ceil(SIZE) + 1; // slight overdraw
      ctx.fillRect(x, y, s, s);
    }

    ctx.restore();
  } else {
    // Particles flying to buttons (keep snapped/overdraw too)
    ctx.fillStyle = '#111111';
    for (const p of particles) {
      if (p.disappeared) continue;

      let opacity = 1;
      if (p.flying && p.targetButton) {
        const dx = p.targetButton.x - p.x;
        const dy = p.targetButton.y - p.y;
        const dist = Math.hypot(dx, dy);
        opacity = Math.max(0, Math.min(1, dist / (30 * DPR)));
      }

      if (opacity > 0) {
        const s = Math.ceil(CELL * 0.8) + 1; // +1px to kill seams
        const x = Math.round(p.x - s/2);
        const y = Math.round(p.y - s/2);
        if (opacity !== 1) ctx.globalAlpha = opacity;
        ctx.fillRect(x, y, s, s);
        if (opacity !== 1) ctx.globalAlpha = 1;
      }
    }
  }
}


  function frame(now){
    const dt = Math.min(60, now - last); last = now; step(dt); draw(); requestAnimationFrame(frame);
  }

  fit(); buildPhrase(); positionPhrase(); requestAnimationFrame(frame);
})();
  </script>
</body>
</html>
